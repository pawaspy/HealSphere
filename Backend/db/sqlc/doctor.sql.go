// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: doctor.sql

package db

import (
	"context"
)

const checkDoctorEmailExists = `-- name: CheckDoctorEmailExists :one
SELECT EXISTS(SELECT 1 FROM doctors WHERE email = $1) AS exists
`

func (q *Queries) CheckDoctorEmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, checkDoctorEmailExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkDoctorUsernameExists = `-- name: CheckDoctorUsernameExists :one
SELECT EXISTS(SELECT 1 FROM doctors WHERE username = $1) AS exists
`

func (q *Queries) CheckDoctorUsernameExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRow(ctx, checkDoctorUsernameExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createDoctor = `-- name: CreateDoctor :one
INSERT INTO doctors (
    username,
    name,
    email,
    password_hash,
    phone,
    gender,
    specialization,
    qualification,
    experience
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING username, name, email, password_hash, phone, gender, specialization, qualification, experience, created_at, updated_at
`

type CreateDoctorParams struct {
	Username       string `json:"username"`
	Name           string `json:"name"`
	Email          string `json:"email"`
	PasswordHash   string `json:"password_hash"`
	Phone          string `json:"phone"`
	Gender         string `json:"gender"`
	Specialization string `json:"specialization"`
	Qualification  string `json:"qualification"`
	Experience     int32  `json:"experience"`
}

func (q *Queries) CreateDoctor(ctx context.Context, arg CreateDoctorParams) (Doctor, error) {
	row := q.db.QueryRow(ctx, createDoctor,
		arg.Username,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.Phone,
		arg.Gender,
		arg.Specialization,
		arg.Qualification,
		arg.Experience,
	)
	var i Doctor
	err := row.Scan(
		&i.Username,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Gender,
		&i.Specialization,
		&i.Qualification,
		&i.Experience,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDoctor = `-- name: DeleteDoctor :exec
DELETE FROM doctors
WHERE username = $1
`

func (q *Queries) DeleteDoctor(ctx context.Context, username string) error {
	_, err := q.db.Exec(ctx, deleteDoctor, username)
	return err
}

const getDoctorByEmail = `-- name: GetDoctorByEmail :one
SELECT username, name, email, password_hash, phone, gender, specialization, qualification, experience, created_at, updated_at FROM doctors
WHERE email = $1
`

func (q *Queries) GetDoctorByEmail(ctx context.Context, email string) (Doctor, error) {
	row := q.db.QueryRow(ctx, getDoctorByEmail, email)
	var i Doctor
	err := row.Scan(
		&i.Username,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Gender,
		&i.Specialization,
		&i.Qualification,
		&i.Experience,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDoctorByUsername = `-- name: GetDoctorByUsername :one
SELECT username, name, email, password_hash, phone, gender, specialization, qualification, experience, created_at, updated_at FROM doctors
WHERE username = $1
`

func (q *Queries) GetDoctorByUsername(ctx context.Context, username string) (Doctor, error) {
	row := q.db.QueryRow(ctx, getDoctorByUsername, username)
	var i Doctor
	err := row.Scan(
		&i.Username,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Gender,
		&i.Specialization,
		&i.Qualification,
		&i.Experience,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDoctors = `-- name: ListDoctors :many
SELECT username, name, email, password_hash, phone, gender, specialization, qualification, experience, created_at, updated_at FROM doctors
ORDER BY created_at
LIMIT $1 OFFSET $2
`

type ListDoctorsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDoctors(ctx context.Context, arg ListDoctorsParams) ([]Doctor, error) {
	rows, err := q.db.Query(ctx, listDoctors, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Doctor{}
	for rows.Next() {
		var i Doctor
		if err := rows.Scan(
			&i.Username,
			&i.Name,
			&i.Email,
			&i.PasswordHash,
			&i.Phone,
			&i.Gender,
			&i.Specialization,
			&i.Qualification,
			&i.Experience,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDoctorsBySpecialization = `-- name: ListDoctorsBySpecialization :many
SELECT username, name, email, password_hash, phone, gender, specialization, qualification, experience, created_at, updated_at FROM doctors
WHERE specialization = $1
ORDER BY created_at
LIMIT $2 OFFSET $3
`

type ListDoctorsBySpecializationParams struct {
	Specialization string `json:"specialization"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

func (q *Queries) ListDoctorsBySpecialization(ctx context.Context, arg ListDoctorsBySpecializationParams) ([]Doctor, error) {
	rows, err := q.db.Query(ctx, listDoctorsBySpecialization, arg.Specialization, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Doctor{}
	for rows.Next() {
		var i Doctor
		if err := rows.Scan(
			&i.Username,
			&i.Name,
			&i.Email,
			&i.PasswordHash,
			&i.Phone,
			&i.Gender,
			&i.Specialization,
			&i.Qualification,
			&i.Experience,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDoctorPassword = `-- name: UpdateDoctorPassword :exec
UPDATE doctors
SET
    password_hash = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE username = $1
`

type UpdateDoctorPasswordParams struct {
	Username     string `json:"username"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) UpdateDoctorPassword(ctx context.Context, arg UpdateDoctorPasswordParams) error {
	_, err := q.db.Exec(ctx, updateDoctorPassword, arg.Username, arg.PasswordHash)
	return err
}

const updateDoctorProfile = `-- name: UpdateDoctorProfile :one
UPDATE doctors
SET
    name = $2,
    email = $3,
    phone = $4,
    gender = $5,
    specialization = $6,
    qualification = $7,
    experience = $8,
    updated_at = CURRENT_TIMESTAMP
WHERE username = $1
RETURNING username, name, email, password_hash, phone, gender, specialization, qualification, experience, created_at, updated_at
`

type UpdateDoctorProfileParams struct {
	Username       string `json:"username"`
	Name           string `json:"name"`
	Email          string `json:"email"`
	Phone          string `json:"phone"`
	Gender         string `json:"gender"`
	Specialization string `json:"specialization"`
	Qualification  string `json:"qualification"`
	Experience     int32  `json:"experience"`
}

func (q *Queries) UpdateDoctorProfile(ctx context.Context, arg UpdateDoctorProfileParams) (Doctor, error) {
	row := q.db.QueryRow(ctx, updateDoctorProfile,
		arg.Username,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Gender,
		arg.Specialization,
		arg.Qualification,
		arg.Experience,
	)
	var i Doctor
	err := row.Scan(
		&i.Username,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Gender,
		&i.Specialization,
		&i.Qualification,
		&i.Experience,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
